<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Jetan — 10x10</title>
    <style>
      :root {
        --bg: #111;
        --panel: #1b1b1b;
        --text: #f2f2f2;
        --muted: #a1a1a1;
        --accent: #6bd1ff;
        --orange: #ff8c42;
        --black: #444;
        --sq-light: #ebecd0;
        --sq-dark: #baca44;
        --sq-hint: rgba(107, 209, 255, 0.35);
        --sq-legal: rgba(107, 209, 255, 0.6);
        --sq-last: rgba(255, 190, 0, 0.4);
        --danger: #ff6464;
        --ok: #79d38d;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      a {
        color: var(--accent);
      }
      .wrap {
        display: grid;
        grid-template-columns: 340px 1fr;
        gap: 20px;
        padding: 20px;
        height: 100%;
      }
      .panel {
        background: var(--panel);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      h1 {
        margin: 0 0 12px;
        font-size: 20px;
        font-weight: 600;
        letter-spacing: 0.2px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      .row input[type="text"] {
        flex: 1 1 160px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #2b2b2b;
        background: #0f0f0f;
        color: var(--text);
        outline: none;
      }
      .btn {
        appearance: none;
        border: 0;
        background: #262626;
        color: var(--text);
        padding: 10px 14px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 600;
      }
      .btn:hover {
        filter: brightness(1.15);
      }
      .btn.primary {
        background: var(--accent);
        color: #002233;
      }
      .btn.warn {
        background: var(--danger);
      }
      .btn.ok {
        background: var(--ok);
        color: #002b14;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      .kv {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 6px 12px;
        margin-top: 8px;
      }
      .kv div {
        color: var(--muted);
        font-size: 12px;
      }
      .kv span {
        color: var(--text);
        font-size: 13px;
      }
      .board-wrap {
        display: grid;
        place-items: center;
      }
      .board {
        width: min(90vmin, 800px);
        height: min(90vmin, 800px);
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        position: relative;
      }
      .sq {
        display: grid;
        place-items: center;
        font-weight: 700;
        user-select: none;
        position: relative;
      }
      .sq::after {
        content: "";
        position: absolute;
        inset: 4px;
        border-radius: 10px;
        pointer-events: none;
      }
      .sq.light {
        background: var(--sq-light);
        color: #222;
      }
      .sq.dark {
        background: var(--sq-dark);
        color: #111;
      }
      .sq.hint::after {
        background: var(--sq-hint);
      }
      .sq.legal::after {
        background: var(--sq-legal);
      }
      .sq.last::after {
        background: var(--sq-last);
      }
      .piece {
        width: 82%;
        height: 82%;
        border-radius: 14px;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 6px;
        cursor: grab;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        font-size: clamp(10px, 2.1vmin, 18px);
      }
      .piece.orange {
        background: linear-gradient(145deg, #ffaf6b, #ff8c42);
        color: #341a00;
      }
      .piece.black {
        background: linear-gradient(145deg, #666, #333);
        color: #eee;
      }
      .pill {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 999px;
        background: #1f1f1f;
        font-size: 12px;
      }
      .status {
        margin-top: 10px;
        padding: 10px;
        border-radius: 12px;
        background: #121212;
        font-size: 13px;
        min-height: 36px;
      }
      .row .pill {
        margin-right: 6px;
      }
      .sep {
        height: 1px;
        background: #2a2a2a;
        margin: 14px 0;
      }
      .bad {
        color: var(--danger);
      }
      .good {
        color: var(--ok);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel">
        <h1>Jetan Control</h1>
        <div class="row">
          <input
            id="gameIdInput"
            class="mono"
            type="text"
            placeholder="Game ID (leave empty to create)"
          />
          <button id="createBtn" class="btn primary">Create game</button>
        </div>
        <div class="row">
          <button id="loadBtn" class="btn">Load game</button>
          <button id="joinOrangeBtn" class="btn ok">Join Orange</button>
          <button id="joinBlackBtn" class="btn warn">Join Black</button>
        </div>
        <div class="row">
          <button id="autoplayBtn" class="btn">Auto‑play (random)</button>
          <button id="resignBtn" class="btn warn">Resign</button>
        </div>
        <div class="kv">
          <div>Game ID</div>
          <span id="kvGame" class="mono">—</span>
          <div>Seat</div>
          <span id="kvSeat">—</span>
          <div>To move</div>
          <span id="kvToMove">—</span>
          <div>Version</div>
          <span id="kvVer">—</span>
        </div>
        <div class="sep"></div>
        <div class="hint">
          Tip: drag your pieces. Legal squares highlight when you start
          dragging.
        </div>
        <div class="status mono" id="status">Ready.</div>
      </div>
      <div class="board-wrap">
        <div id="board" class="board" aria-label="Jetan board 10 by 10"></div>
      </div>
    </div>

    <script>
      (() => {
        const API = {
          create: () =>
            fetch("/api/v1/games", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ variant: "standard" }),
            }),
          snapshot: (gid) => fetch(`/api/v1/games/${gid}`),
          join: (gid, seat) =>
            fetch(`/api/v1/games/${gid}/join`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ seat }),
            }),
          legal: (gid, row, col) =>
            fetch(`/api/v1/games/${gid}/legal?row=${row}&col=${col}`),
          move: (gid, version, payload) =>
            fetch(`/api/v1/games/${gid}/moves`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "If-Match": String(version),
              },
              body: JSON.stringify(payload),
            }),
          diffs: (gid, since) =>
            fetch(`/api/v1/games/${gid}/diffs?since=${since}`),
          control: (gid, action) =>
            fetch(`/api/v1/games/${gid}/controls`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ action }),
            }),
        };

        const boardEl = document.getElementById("board");
        const statusEl = document.getElementById("status");
        const kvGame = document.getElementById("kvGame");
        const kvSeat = document.getElementById("kvSeat");
        const kvToMove = document.getElementById("kvToMove");
        const kvVer = document.getElementById("kvVer");
        const gameIdInput = document.getElementById("gameIdInput");

        const createBtn = document.getElementById("createBtn");
        const loadBtn = document.getElementById("loadBtn");
        const joinOrangeBtn = document.getElementById("joinOrangeBtn");
        const joinBlackBtn = document.getElementById("joinBlackBtn");
        const autoplayBtn = document.getElementById("autoplayBtn");
        const resignBtn = document.getElementById("resignBtn");

        // Game state in the UI
        let GID = null;
        let VERSION = null;
        let SEAT = null; // "orange" | "black" | null
        let STATE = null; // snapshot.state-like
        let POLL = null;
        let AUTO = null;
        let lastMove = null;

        const abbrev = (type) => {
          const map = {
            Warrior: "Wa",
            Padwar: "Pa",
            Dwar: "Dw",
            Flier: "Fl",
            Princess: "Pr",
            Chief: "Ch",
            Thoat: "Th",
            Panthan: "Pn",
          };
          return map[type] || type.slice(0, 2);
        };

        function status(msg, cls) {
          statusEl.textContent = msg;
          statusEl.className = "status mono" + (cls ? " " + cls : "");
        }

        function buildBoard() {
          boardEl.innerHTML = "";
          const grid = [];
          for (let r = 0; r < 10; r++) {
            grid[r] = new Array(10).fill(null);
            for (let c = 0; c < 10; c++) {
              const sq = document.createElement("div");
              sq.className = "sq " + ((r + c) % 2 === 0 ? "light" : "dark");
              sq.id = `sq-${r}-${c}`;
              sq.dataset.row = r;
              sq.dataset.col = c;
              sq.addEventListener("dragover", (ev) => ev.preventDefault());
              sq.addEventListener("drop", onDrop);
              boardEl.appendChild(sq);
            }
          }
        }

        function renderPieces() {
          document.querySelectorAll(".sq").forEach((sq) => {
            sq.classList.remove("legal", "hint", "last");
            sq.innerHTML = "";
          });
          if (!STATE) return;
          // Mark last move
          if (lastMove) {
            const a = document.getElementById(
              `sq-${lastMove.from.row}-${lastMove.from.col}`
            );
            const b = document.getElementById(
              `sq-${lastMove.to.row}-${lastMove.to.col}`
            );
            a && a.classList.add("last");
            b && b.classList.add("last");
          }
          for (const p of STATE.pieces) {
            const sq = document.getElementById(
              `sq-${p.square.row}-${p.square.col}`
            );
            if (!sq) continue;
            const el = document.createElement("div");
            el.className =
              "piece " + (p.color === "ORANGE" ? "orange" : "black");
            el.textContent = `${abbrev(p.type)}`;
            el.draggable = SEAT && p.color.toLowerCase() === SEAT;
            el.dataset.row = p.square.row;
            el.dataset.col = p.square.col;
            el.dataset.type = p.type;
            el.addEventListener("dragstart", onDragStart);
            el.addEventListener("dragend", onDragEnd);
            sq.appendChild(el);
          }
          kvToMove.textContent = STATE.toMove || "—";
        }

        async function createGame() {
          const res = await API.create();
          const js = await res.json();
          GID = js.gameId;
          VERSION = js.version ?? (parseInt(res.headers.get("ETag")) || 0);
          STATE = js.state;
          gameIdInput.value = GID;
          kvGame.textContent = GID;
          kvVer.textContent = VERSION;
          status("Created game " + GID, "good");
          startPolling();
          renderPieces();
        }

        async function loadGame() {
          const gid = gameIdInput.value.trim();
          if (!gid) {
            status("Enter a game ID to load.", "bad");
            return;
          }
          const res = await API.snapshot(gid);
          if (!res.ok) {
            status(
              "Failed to load game " + gid + " (" + res.status + ")",
              "bad"
            );
            return;
          }
          const js = await res.json();
          GID = js.gameId;
          VERSION = js.version ?? (parseInt(res.headers.get("ETag")) || 0);
          STATE = js.state;
          kvGame.textContent = GID;
          kvVer.textContent = VERSION;
          status("Loaded game " + GID, "good");
          startPolling();
          renderPieces();
        }

        async function join(seat) {
          if (!GID) return status("Create or load a game first.", "bad");
          const res = await API.join(GID, seat);
          if (!res.ok) {
            status("Join failed: " + res.status, "bad");
            return;
          }
          const js = await res.json();
          SEAT = js.seat || seat;
          kvSeat.textContent = SEAT || "—";
          status("Joined as " + SEAT, "good");
          await refresh();
        }

        async function refresh() {
          if (!GID) return;
          const res = await API.snapshot(GID);
          if (!res.ok) {
            return;
          }
          const js = await res.json();
          VERSION = js.version ?? (parseInt(res.headers.get("ETag")) || 0);
          STATE = js.state;
          kvVer.textContent = VERSION;
          renderPieces();
        }

        function startPolling() {
          if (POLL) clearInterval(POLL);
          POLL = setInterval(async () => {
            if (!GID || VERSION == null) return;
            try {
              const res = await API.diffs(GID, VERSION);
              if (res.status === 200) {
                const js = await res.json();
                if (js && js.toVersion && js.toVersion !== VERSION) {
                  VERSION = js.toVersion;
                  kvVer.textContent = VERSION;
                  await refresh();
                }
              } else if (res.status === 409) {
                // Need snapshot
                await refresh();
              }
            } catch (e) {}
          }, 1000);
        }

        let dragCtx = null;
        async function onDragStart(ev) {
          const piece = ev.currentTarget;
          const row = parseInt(piece.dataset.row),
            col = parseInt(piece.dataset.col);
          dragCtx = { from: { row, col } };
          if (!GID) return;

          // Ask server for legal moves for this square
          const res = await API.legal(GID, row, col);
          if (res.ok) {
            const js = await res.json();
            VERSION = js.version ?? (parseInt(res.headers.get("ETag")) || 0);
            kvVer.textContent = VERSION;
            document
              .querySelectorAll(".sq")
              .forEach((s) => s.classList.remove("hint", "legal"));
            for (const d of js.destinations) {
              const sq = document.getElementById(`sq-${d.row}-${d.col}`);
              if (sq) sq.classList.add("legal");
            }
            const fromSq = document.getElementById(`sq-${row}-${col}`);
            fromSq && fromSq.classList.add("hint");
          }
        }
        function onDragEnd(ev) {
          document
            .querySelectorAll(".sq")
            .forEach((s) => s.classList.remove("hint", "legal"));
        }

        async function onDrop(ev) {
          ev.preventDefault();
          if (!dragCtx || !GID) return;
          const to = {
            row: parseInt(this.dataset.row),
            col: parseInt(this.dataset.col),
          };
          const payload = { from: dragCtx.from, to };
          const res = await API.move(GID, VERSION, payload);
          if (res.status === 200) {
            const js = await res.json();
            VERSION = js.version ?? (parseInt(res.headers.get("ETag")) || 0);
            kvVer.textContent = VERSION;
            lastMove = payload;
            await refresh();
            status("Move applied.", "good");
          } else if (res.status === 409) {
            await refresh();
            status("Version conflict. Synced.", "bad");
          } else {
            status("Move rejected (" + res.status + ").", "bad");
          }
          dragCtx = null;
        }

        async function control(action) {
          if (!GID) return status("No game.", "bad");
          const res = await API.control(GID, action);
          if (!res.ok)
            return status("Control failed (" + res.status + ")", "bad");
          await refresh();
        }

        async function autoplayLoop() {
          if (!GID) return;
          if (AUTO) {
            clearInterval(AUTO);
            AUTO = null;
            autoplayBtn.textContent = "Auto‑play (random)";
            status("Auto‑play stopped.");
            return;
          }
          autoplayBtn.textContent = "Stop auto‑play";
          status("Auto‑play started (random legal moves).");
          AUTO = setInterval(async () => {
            try {
              // Build a list of all legal moves by asking /legal for every piece square
              await refresh();
              if (!STATE || STATE.result) {
                clearInterval(AUTO);
                AUTO = null;
                autoplayBtn.textContent = "Auto‑play (random)";
                return;
              }
              const toMove = (STATE.toMove || "").toLowerCase();
              const mySquares = STATE.pieces
                .filter((p) => p.color.toLowerCase() === toMove)
                .map((p) => p.square);
              const candidateMoves = [];
              for (const sq of mySquares) {
                const r = await API.legal(GID, sq.row, sq.col);
                if (!r.ok) continue;
                const js = await r.json();
                for (const d of js.destinations)
                  candidateMoves.push({
                    from: { row: sq.row, col: sq.col },
                    to: d,
                  });
              }
              if (candidateMoves.length === 0) {
                clearInterval(AUTO);
                AUTO = null;
                autoplayBtn.textContent = "Auto‑play (random)";
                status("No legal moves; stopping.");
                return;
              }
              const choice =
                candidateMoves[
                  Math.floor(Math.random() * candidateMoves.length)
                ];
              const m = await API.move(GID, VERSION, choice);
              if (m.status === 200) {
                VERSION = parseInt(m.headers.get("ETag")) || VERSION;
                lastMove = choice;
              } else {
                await refresh();
              }
            } catch (e) {
              // ignore transient errors
            }
          }, 600);
        }

        // Wire up controls
        createBtn.onclick = createGame;
        loadBtn.onclick = loadGame;
        joinOrangeBtn.onclick = () => join("orange");
        joinBlackBtn.onclick = () => join("black");
        autoplayBtn.onclick = autoplayLoop;
        resignBtn.onclick = () => control("resign");

        buildBoard();
        status("Ready. Create or load a game.");
      })();
    </script>
  </body>
</html>
